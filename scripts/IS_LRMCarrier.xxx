-- Test Tank Script

--defines
local body, turret, launcher = piece ("body", "turret", "launcher")
local trackr, trackl = piece ("trackr", "trackl")
local smokePieces = {body, turret}
local LaunchPointsA = {}
local currLaunchPointA = 1
local numLaunchPointsA = 20
	for i = 1, numLaunchPointsA do
		LaunchPointsA[i] = piece ("launchpointa"..i)
	end
local LaunchPointsB = {}
local currLaunchPointB = 1
local numLaunchPointsB = 20
	for i = 1, numLaunchPointsB do
		LaunchPointsB[i] = piece ("launchpointb"..i)
	end
local LaunchPointsC = {}
local currLaunchPointC = 1
local numLaunchPointsC = 20
	for i = 1, numLaunchPointsC do
		LaunchPointsC[i] = piece ("launchpointc"..i)
	end
local wheels = {}
local numWheels = 8
	for i = 1, numWheels do
		wheels[i] = piece ("wheel"..i)
	end
local rad = math.rad

-- constants
local SIG_AIM1 = 2
local SIG_AIM2 = 4
local SIG_AIM3 = 8

local RESTORE_DELAY = Spring.UnitScript.GetLongestReloadTime(unitID) * 2

-- includes
include "smokeunit.lua"

--SFX defines
MEDIUM_MUZZLEFLASH = SFX.CEG+0

function script.Create()
	StartThread(SmokeUnit())
end

local function SpinWheels(moving)
	if moving then
		for i = 1, numWheels do
			Spin(wheels[i], x_axis, rad(200), rad(100))
		end
	else
		for i = 1, numWheels do
			StopSpin(wheels[i], x_axis, rad(100))
		end
	end	
end

function script.StartMoving()
	SpinWheels(true)
end

function script.StopMoving()
	SpinWheels(false)
end

local function RestoreAfterDelay(unitID)
	Sleep(RESTORE_DELAY)
	Turn(turret, y_axis, 0, math.rad(50))
	Turn(launcher, x_axis, 0, math.rad(100))
end
	
	function script.AimWeapon1(heading, pitch)
	Signal(SIG_AIM1)
	SetSignalMask(SIG_AIM1)
	Turn(turret, y_axis, heading, rad(25))
	Turn(launcher, x_axis, -pitch, rad(50))
	WaitForTurn(turret, y_axis)
	StartThread(RestoreAfterDelay)
	return true
end

function script.FireWeapon1()
end

function script.Shot1()
	EmitSfx(LaunchPointsA[currLaunchPointA], MEDIUM_MUZZLEFLASH)
	currLaunchPointA = currLaunchPointA + 1
	if currLaunchPointA > numLaunchPointsA then 
		currLaunchPointA = 1
	end
end

function script.AimFromWeapon2() 
	return turret 
end

function script.QueryWeapon2() 
	return LaunchPointsA[currLaunchPointA]
end

function script.AimWeapon2(heading, pitch)
	Signal(SIG_AIM2)
	SetSignalMask(SIG_AIM2)
	Turn(turret, y_axis, heading, rad(25))
	Turn(launcher, x_axis, -pitch, rad(50))
	WaitForTurn(turret, y_axis)
	StartThread(RestoreAfterDelay)
	return true
end

function script.FireWeapon2()
end

function script.Shot2()
	EmitSfx(LaunchPointsB[currLaunchPointB], MEDIUM_MUZZLEFLASH)
	currLaunchPointB = currLaunchPointB + 1
	if currLaunchPointB > numLaunchPointsB then 
		currLaunchPointB = 1
	end
end

function script.AimFromWeapon2() 
	return turret 
end

function script.QueryWeapon2() 
	return LaunchPointsB[currLaunchPointB]
end

function script.AimWeapon3(heading, pitch)
	Signal(SIG_AIM3)
	SetSignalMask(SIG_AIM3)
	Turn(turret, y_axis, heading, rad(25))
	Turn(launcher, x_axis, -pitch, rad(50))
	WaitForTurn(turret, y_axis)
	StartThread(RestoreAfterDelay)
	return true
end

function script.FireWeapon3()
end

function script.Shot3()
	EmitSfx(LaunchPointsC[currLaunchPointC], MEDIUM_MUZZLEFLASH)
	currLaunchPointC = currLaunchPointC + 1
	if currLaunchPointC > numLaunchPointsC then 
		currLaunchPointC = 1
	end
end

function script.AimFromWeapon3() 
	return turret 
end

function script.QueryWeapon3() 
	return LaunchPointsC[currLaunchPointC]
end
function script.Killed(recentDamage, maxHealth)
	--local severity = recentDamage / maxHealth * 100
	--if severity <= 25 then
	--	Explode(body, math.bit_or({SFX.BITMAPONLY, SFX.BITMAP1}))
	--	return 1
	--elseif severity <= 50 then
	--	Explode(body, math.bit_or({SFX.FALL, SFX.BITMAP1}))
	--	return 2
	--else
	--	Explode(body, math.bit_or({SFX.FALL, SFX.SMOKE, SFX.FIRE, SFX.EXPLODE_ON_HIT, SFX.BITMAP1}))
	--	return 3
	--end
end
